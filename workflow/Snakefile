# SPDX-FileCopyrightText: 2025 Koen van Greevenbroek
#
# SPDX-License-Identifier: GPL-3.0-or-later

from snakemake.utils import min_version
import os

min_version("9.0")

os.makedirs("data/downloads", exist_ok=True)


configfile: "config/config.yaml"


name = config["name"]


include: "rules/retrieve.smk"
include: "rules/plotting.smk"


wildcard_constraints:
    climate_model=r"[a-zA-Z0-9\-]+",
    variable=r"[a-z]+",
    time_period=r"2020s|2050s|2080s",
    rcp=r"[0-9]p[0-9]",
    input_management=r"H|L",
    water_supply=r"r|i",
    co2_fertilization=r"0*",
    crop=r"[a-z\-\w]+",


rule all:
    input:
        f"results/{name}/solved/model.nc",
        # results plots
        f"results/{name}/plots/crop_production.pdf",
        f"results/{name}/plots/food_production.pdf",
        f"results/{name}/plots/resource_usage.pdf",
        f"results/{name}/plots/crop_production.csv",
        f"results/{name}/plots/food_production.csv",
        # maps
        f"results/{name}/plots/regions_map.pdf",
        f"results/{name}/plots/crop_production_map.pdf",


rule prepare_population:
    input:
        population_gz="data/downloads/WPP_population.csv.gz",
    params:
        planning_horizon=config["planning_horizon"],
    output:
        f"processing/{name}/population.csv",
    script:
        "scripts/prepare_population.py"


rule simplify_gadm:
    input:
        "data/downloads/gadm.gpkg",
    params:
        simplify_min_area_km=config["aggregation"]["simplify_min_area_km"],
        simplify_tolerance_km=config["aggregation"]["simplify_tolerance_km"],
    output:
        "processing/shared/gadm-simplified.gpkg",
    script:
        "scripts/simplify_gadm.py"


rule build_regions:
    input:
        world="processing/shared/gadm-simplified.gpkg",
    params:
        n_regions=config["aggregation"]["regions"]["target_count"],
        allow_cross_border=config["aggregation"]["regions"]["allow_cross_border"],
        cluster_method=config["aggregation"]["regions"]["method"],
        countries=config["countries"],
    output:
        "processing/{name}/regions.geojson",
    script:
        "scripts/build_regions.py"


rule build_crop_yields:
    input:
        yields="data/downloads/gaez_potential_yield_{climate_model}_{time_period}_{rcp}_{input_management}_{water_supply}_{co2_fertilization}_{crop}.tif",
        suitability="data/downloads/gaez_suitability_{climate_model}_{time_period}_{rcp}_{input_management}_{water_supply}_{co2_fertilization}_{crop}.tif",
        regions=f"processing/{name}/regions.geojson",
    params:
        resource_class_quantiles=config["aggregation"]["resource_class_quantiles"],
    output:
        os.path.join(
            "processing",
            name,
            "crop_yields/{climate_model}_{time_period}_{rcp}_{input_management}_{water_supply}_{co2_fertilization}_{crop}.csv",
        ),
    script:
        "scripts/build_crop_yields.py"


def suitability_inputs(wildcards):
    gaez = config["data"]["gaez"]
    return {
        crop: f"data/downloads/gaez_suitability_{gaez['climate_model']}_{gaez['time_period']}_{gaez['rcp']}_{gaez['input_management']}_{gaez['water_supply']}_{gaez['co2_fertilization']}_{gaez['crops'][crop]}.tif"
        for crop in config["crops"]
    }


rule build_region_crop_areas:
    input:
        unpack(suitability_inputs),
        regions=f"processing/{name}/regions.geojson",
    params:
        crops=config["crops"],
    output:
        "processing/{name}/region_crop_areas.csv",
    script:
        "scripts/build_region_crop_areas.py"


def yield_inputs(wildcards):
    gaez = config["data"]["gaez"]
    return {
        crop
        + "_yield": f"processing/{name}/crop_yields/{gaez['climate_model']}_{gaez['time_period']}_{gaez['rcp']}_{gaez['input_management']}_{gaez['water_supply']}_{gaez['co2_fertilization']}_{gaez['crops'][crop]}.csv"
        for crop in config["crops"]
    }


def yield_gap_raster_inputs(wildcards):
    gaez = config["data"]["gaez"]
    return {
        "potential_yield": (
            f"data/downloads/gaez_potential_yield_{gaez['climate_model']}_{gaez['time_period']}_{gaez['rcp']}_{gaez['input_management']}_{gaez['water_supply']}_{gaez['co2_fertilization']}_{gaez['crops'][wildcards.crop]}.tif"
        ),
        "actual_yield": (
            f"data/downloads/gaez_actual_yield_{gaez['actual_yield_year']}_{gaez['water_supply']}_{gaez['crops'][wildcards.crop]}.tif"
        ),
    }


# Average actual/potential by country, using regions dissolved by 'country'.
rule yield_gap_by_country:
    input:
        unpack(yield_gap_raster_inputs),
        regions=f"processing/{name}/regions.geojson",
    params:
        countries=config["countries"],
    output:
        csv=f"processing/{name}/yield_gap_by_country_{{crop}}.csv",
    script:
        "scripts/compute_yield_gap_by_country.py"


def yield_gap_country_csvs(wildcards):
    # Per-crop country CSVs produced by rule yield_gap_by_country
    return [
        f"processing/{name}/yield_gap_by_country_{crop}.csv"
        for crop in config["crops"]
        if gaez["crops"][crop] in gaez["actual_yield_crops"]
    ]


# Average actual/potential by country across all crops
rule average_yield_gap_by_country:
    input:
        yield_gap_country_csvs,
    output:
        csv=f"processing/{name}/yield_gap_by_country_all_crops.csv",
    script:
        "scripts/aggregate_yield_gap_all_crops.py"


rule build_model:
    input:
        unpack(yield_inputs),
        crops="data/crops.csv",
        foods="data/foods.csv",
        food_groups="data/food_groups.csv",
        nutrition="data/nutrition.csv",
        regions="processing/{name}/regions.geojson",
        region_crop_areas="processing/{name}/region_crop_areas.csv",
        population="processing/{name}/population.csv",
    params:
        crops=config["crops"],
        countries=config["countries"],
        primary=config["primary"],
        food_groups=config["food_groups"],
        macronutrients=config["macronutrients"],
        trade=config["trade"],
    output:
        network="results/{name}/build/model.nc",
    script:
        "scripts/build_model.py"


rule solve_model:
    input:
        network="results/{name}/build/model.nc",
    params:
        primary=config["primary"],
        ghg_price=config["emissions"]["ghg_price"],
        solver=config["solving"]["solver"],
        solver_options=config["solving"].get(
            f"options_{config['solving']['solver']}", {}
        ),
    output:
        network="results/{name}/solved/model.nc",
    script:
        "scripts/solve_model.py"
