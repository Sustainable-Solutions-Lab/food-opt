# SPDX-FileCopyrightText: 2025 Koen van Greevenbroek
#
# SPDX-License-Identifier: GPL-3.0-or-later

from snakemake.utils import min_version
import os
import itertools
import pandas as pd

min_version("9.0")

os.makedirs("data/downloads", exist_ok=True)


configfile: "config/config.yaml"


name = config["name"]
gaez_cfg = config["data"]["gaez"]
grazing_cfg = config.get("grazing", {})


include: "rules/retrieve.smk"
include: "rules/plotting.smk"
include: "rules/yield_gaps.smk"


wildcard_constraints:
    climate_model=r"[a-zA-Z0-9\-]+",
    variable=r"[a-z]+",
    time_period=r"2020s|2050s|2080s",
    rcp=r"[0-9]p[0-9]",
    input_management=r"H|L",
    water_supply=r"r|i|g|s|d",
    co2_fertilization=r"0*",
    crop=r"[a-z\-\w]+",
    item=r"[a-zA-Z0-9_-]+",
    supply=r"i|r|pasture",


rule all:
    input:
        f"results/{name}/solved/model.nc",
        # results plots
        f"results/{name}/plots/crop_production.pdf",
        f"results/{name}/plots/resource_usage.pdf",
        f"results/{name}/plots/crop_production.csv",
        f"results/{name}/plots/food_production.csv",
        f"results/{name}/plots/objective_breakdown.pdf",
        f"results/{name}/plots/objective_breakdown.csv",
        f"results/{name}/plots/health_risk_map.pdf",
        f"results/{name}/plots/health_risk_by_region.csv",
        f"results/{name}/plots/health_baseline_map.pdf",
        f"results/{name}/plots/health_baseline_by_region.csv",
        # maps
        f"results/{name}/plots/regions_map.pdf",
        f"results/{name}/plots/resource_classes_map.pdf",
        f"results/{name}/plots/crop_production_map.pdf",
        f"results/{name}/plots/crop_land_use_map.pdf",
        f"results/{name}/plots/cropland_fraction_map.pdf",
        f"results/{name}/plots/crop_use_breakdown.pdf",
        f"results/{name}/plots/crop_use_breakdown.csv",


rule prepare_population:
    input:
        population_gz="data/downloads/WPP_population.csv.gz",
    params:
        planning_horizon=config["planning_horizon"],
        countries=config["countries"],
        health_reference_year=config["health"]["reference_year"],
    output:
        population=f"processing/{name}/population.csv",
        population_age=f"processing/{name}/population_age.csv",
    script:
        "scripts/prepare_population.py"


rule simplify_gadm:
    input:
        "data/downloads/gadm.gpkg",
    params:
        simplify_min_area_km=config["aggregation"]["simplify_min_area_km"],
        simplify_tolerance_km=config["aggregation"]["simplify_tolerance_km"],
    output:
        "processing/shared/gadm-simplified.gpkg",
    script:
        "scripts/simplify_gadm.py"


rule build_regions:
    input:
        world="processing/shared/gadm-simplified.gpkg",
    params:
        n_regions=config["aggregation"]["regions"]["target_count"],
        allow_cross_border=config["aggregation"]["regions"]["allow_cross_border"],
        cluster_method=config["aggregation"]["regions"]["method"],
        countries=config["countries"],
    output:
        "processing/{name}/regions.geojson",
    script:
        "scripts/build_regions.py"


rule prepare_health_costs:
    input:
        regions="processing/{name}/regions.geojson",
        diet="data/health/raw/diet_05282021.csv",
        rr_int="data/health/raw/RR_int_05282021.csv",
        rr_max="data/health/raw/RR_max_05282021.csv",
        dr="data/health/raw/dr_05282021.csv",
        population="processing/{name}/population_age.csv",
        life_table="data/health/raw/lftable_05282021.csv",
        vsl="data/health/raw/VSL_reg_10182021.csv",
    params:
        countries=config["countries"],
        health=config["health"],
    output:
        risk_breakpoints="processing/{name}/health/risk_breakpoints.csv",
        cluster_cause="processing/{name}/health/cluster_cause_baseline.csv",
        cause_log="processing/{name}/health/cause_log_breakpoints.csv",
        cluster_summary="processing/{name}/health/cluster_summary.csv",
        clusters="processing/{name}/health/country_clusters.csv",
    script:
        "scripts/prepare_health_costs.py"


# Different types of irrigation are available for different crops in
# GAEZ; some crops don't have irrigated yield data at all. This rule
# queries possible GAEZ urls to determine what is available, and
# compiles an overview by crop. It needs to be a checkpoint since the
# outcome will affect which yield data processing rules are run later
# on in the workflow.
checkpoint detect_irrigated_availability:
    params:
        gaez=config["data"]["gaez"],
        crops=config["crops"],
    output:
        f"processing/{name}/irrigated_available_crops.csv",
    script:
        "scripts/detect_irrigated_availability.py"


def gaez_path(kind: str, water_supply: str, code: str) -> str:
    """Return compact GAEZ raster path for a given kind and water supply.

    kind: one of {"yield", "suitability", "water_requirement", "actual_yield"}
    water_supply: "r" (rainfed) or irrigation type ("i", "g", "s", "d")
    code: GAEZ crop code (e.g., "whe")
    """
    if kind == "yield":
        prefix = "gaez_potential_yield"
        return (
            f"data/downloads/{prefix}_{gaez_cfg['climate_model']}_{gaez_cfg['time_period']}"
            f"_{gaez_cfg['rcp']}_{gaez_cfg['input_management']}_{water_supply}"
            f"_{gaez_cfg['co2_fertilization']}_{code}.tif"
        )
    if kind == "water_requirement":
        prefix = "gaez_water_requirement"
        return (
            f"data/downloads/{prefix}_{gaez_cfg['climate_model']}_{gaez_cfg['time_period']}"
            f"_{gaez_cfg['rcp']}_{gaez_cfg['input_management']}_{water_supply}"
            f"_{gaez_cfg['co2_fertilization']}_{code}.tif"
        )
    if kind == "suitability":
        prefix = "gaez_suitability"
        return (
            f"data/downloads/{prefix}_{gaez_cfg['climate_model']}_{gaez_cfg['time_period']}"
            f"_{gaez_cfg['rcp']}_{gaez_cfg['input_management']}_{water_supply}"
            f"_{gaez_cfg['co2_fertilization']}_{code}.tif"
        )
    if kind == "actual_yield":
        prefix = "gaez_actual_yield"
        return f"data/downloads/{prefix}_{gaez_cfg['actual_yield_year']}_{water_supply}_{code}.tif"
    raise ValueError(f"Unknown kind for _gaez_path: {kind}")


def irrigated_first_type_by_code() -> dict[str, str]:
    """Map crop code -> first available irrig. type from detection CSV."""
    path = checkpoints.detect_irrigated_availability.get(name=name).output[0]
    df = pd.read_csv(path)
    df = df[df["first_available"] != "none"].copy()
    return dict(zip(df["code"].astype(str), df["first_available"]))


def class_inputs_for_yield_max(wildcards):
    # Rainfed for all crops
    files = [
        gaez_path("yield", "r", gaez_cfg["crops"][crop]) for crop in config["crops"]
    ]
    # Irrigated where available: pick the first available type from CSV
    irr_first = irrigated_first_type_by_code()
    for code, t in irr_first.items():
        files.append(gaez_path("yield", t, code))
    return files


rule compute_resource_classes:
    input:
        yields=class_inputs_for_yield_max,
        regions=f"processing/{name}/regions.geojson",
    params:
        resource_class_quantiles=config["aggregation"]["resource_class_quantiles"],
    output:
        classes=f"processing/{name}/resource_classes.nc",
    script:
        "scripts/compute_resource_classes.py"


def suitability_rainfed_inputs(wildcards):
    return [
        gaez_path("suitability", "r", gaez_cfg["crops"][crop])
        for crop in config["crops"]
    ]


def suitability_irrigated_inputs(wildcards):
    files = []
    irr_first = irrigated_first_type_by_code()
    for code, t in irr_first.items():
        files.append(gaez_path("suitability", t, code))
    return files


rule aggregate_class_areas:
    input:
        classes=f"processing/{name}/resource_classes.nc",
        sr=suitability_rainfed_inputs,
        si=suitability_irrigated_inputs,
        irrigated_share="data/downloads/gaez_irrigated_cropland_share.tif",
        regions=f"processing/{name}/regions.geojson",
    params:
        land_limit_dataset=config["aggregation"].get(
            "land_limit_dataset", "suitability"
        ),
    output:
        f"processing/{name}/land_area_by_class.csv",
    script:
        "scripts/aggregate_class_areas.py"


def yield_and_suitability_for_crop(w):
    # Here, the {crop} wildcard is the crop code (e.g., 'whe')
    code = w.crop
    if w.water_supply == "i":
        irr = irrigated_first_type_by_code()
        if code not in irr:
            raise ValueError(f"No irrigated types available for crop code {code}")
        t = irr[code]
    else:
        t = "r"
    y = gaez_path("yield", t, code)
    s = gaez_path("suitability", t, code)
    water = None
    if w.water_supply == "i":
        water = gaez_path("water_requirement", t, code)
    gs_cfg = gaez_cfg["growing_season"]
    start = (
        f"data/downloads/gaez_growing_season_start_{gaez_cfg['climate_model']}"
        f"_{gaez_cfg['time_period']}_{gaez_cfg['rcp']}_{gs_cfg['year']}.tif"
    )
    length = (
        f"data/downloads/gaez_growing_season_length_{gaez_cfg['climate_model']}"
        f"_{gaez_cfg['time_period']}_{gaez_cfg['rcp']}_{gs_cfg['year']}.tif"
    )
    inputs = {
        "yield_raster": y,
        "suitability_raster": s,
        "growing_season_start_raster": start,
        "growing_season_length_raster": length,
    }
    if water is not None:
        inputs["water_requirement_raster"] = water
    return inputs


rule build_crop_yields:
    input:
        unpack(yield_and_suitability_for_crop),
        classes=f"processing/{name}/resource_classes.nc",
        regions=f"processing/{name}/regions.geojson",
        yield_unit_conversions="data/yield_unit_conversions.csv",
    output:
        f"processing/{name}/crop_yields/{{crop}}_{{water_supply}}.csv",
    script:
        "scripts/build_crop_yields.py"


rule build_grassland_yields:
    input:
        grassland="data/downloads/grassland_yield_historical.nc4",
        classes=f"processing/{name}/resource_classes.nc",
        regions=f"processing/{name}/regions.geojson",
    output:
        f"processing/{name}/grassland_yields.csv",
    script:
        "scripts/build_grassland_yields.py"


rule extract_waterfootprint_appendix:
    input:
        zip_path="data/downloads/Report53_Appendix.zip",
    output:
        shapefile="data/downloads/Report53_Appendix/Report53-BlueWaterScarcity-ArcGIS-ShapeFile/Monthly_WS_GRDC_405_basins.shp",
        excel="data/downloads/Report53_Appendix/Report53-Appendices-VI-IX.xls",
    shell:
        r"""
        unzip -o {input.zip_path} -d data/downloads
        """


rule process_blue_water_availability:
    input:
        shapefile=rules.extract_waterfootprint_appendix.output.shapefile,
        excel=rules.extract_waterfootprint_appendix.output.excel,
    output:
        f"processing/{name}/water/blue_water_availability.csv",
    script:
        "scripts/process_blue_water_availability.py"


def crop_yield_file_list(w):
    return list(yield_inputs(w).values())


def irrigated_availability_csv(wildcards):
    return checkpoints.detect_irrigated_availability.get(name=name).output[0]


rule build_region_water_availability:
    input:
        shapefile=rules.extract_waterfootprint_appendix.output.shapefile,
        regions=f"processing/{name}/regions.geojson",
        monthly=f"processing/{name}/water/blue_water_availability.csv",
        crop_yields=crop_yield_file_list,
    params:
        code_to_crop={code: crop for crop, code in gaez_cfg["crops"].items()},
    output:
        monthly_region=f"processing/{name}/water/monthly_region_water.csv",
        region_growing=f"processing/{name}/water/region_growing_season_water.csv",
    script:
        "scripts/build_region_water_availability.py"


def yield_inputs(wildcards):
    # Irrigated crops
    irr_cfg = config["irrigation"]["irrigated_crops"]
    if irr_cfg == "auto":
        irrigated_crops = [
            crop
            for crop in config["crops"]
            if gaez_cfg["crops"][crop] in irrigated_first_type_by_code()
        ]
    else:
        irrigated_crops = list(irr_cfg)

    return {
        f"{crop}_yield_{water_supply}": (
            f"processing/{name}/crop_yields/{gaez_cfg['crops'][crop]}_{water_supply}.csv"
        )
        for crop, water_supply in (
            list(zip(config["crops"], itertools.repeat("r")))  # Rainfed
            + list(zip(irrigated_crops, itertools.repeat("i")))
        )
    }


rule build_model:
    input:
        unpack(yield_inputs),
        irrigation_availability=irrigated_availability_csv,
        crops="data/crops.csv",
        foods="data/foods.csv",
        feed_conversion="data/feed_conversion.csv",
        feed_to_products="data/feed_to_animal_products.csv",
        food_groups="data/food_groups.csv",
        nutrition="data/nutrition.csv",
        regions="processing/{name}/regions.geojson",
        land_area_by_class="processing/{name}/land_area_by_class.csv",
        population="processing/{name}/population.csv",
        prices=f"processing/{name}/faostat_prices.csv",
        grassland_yields=f"processing/{name}/grassland_yields.csv",
        monthly_region_water=f"processing/{name}/water/monthly_region_water.csv",
        growing_season_water=f"processing/{name}/water/region_growing_season_water.csv",
        blue_water_availability=f"processing/{name}/water/blue_water_availability.csv",
    params:
        crops=config["crops"],
        countries=config["countries"],
        primary=config["primary"],
        food_groups=config["food_groups"],
        macronutrients=config["macronutrients"],
        animal_products=config["animal_products"],
        trade=config["trade"],
        grazing=grazing_cfg,
    output:
        network="results/{name}/build/model.nc",
    script:
        "scripts/build_model.py"


rule solve_model:
    input:
        network="results/{name}/build/model.nc",
        health_risk_breakpoints="processing/{name}/health/risk_breakpoints.csv",
        health_cluster_cause="processing/{name}/health/cluster_cause_baseline.csv",
        health_cause_log="processing/{name}/health/cause_log_breakpoints.csv",
        health_cluster_summary="processing/{name}/health/cluster_summary.csv",
        health_clusters="processing/{name}/health/country_clusters.csv",
        food_risk_map="data/health/food_to_risk_factor.csv",
        population="processing/{name}/population.csv",
    params:
        primary=config["primary"],
        ghg_price=config["emissions"]["ghg_price"],
        solver=config["solving"]["solver"],
        solver_options=config["solving"].get(
            f"options_{config['solving']['solver']}", {}
        ),
    output:
        network="results/{name}/solved/model.nc",
    script:
        "scripts/solve_model.py"
