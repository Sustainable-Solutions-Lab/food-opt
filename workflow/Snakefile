# SPDX-FileCopyrightText: 2025 Koen van Greevenbroek
#
# SPDX-License-Identifier: GPL-3.0-or-later

from snakemake.utils import min_version
import os
import itertools
import pandas as pd

min_version("9.0")

os.makedirs("data/downloads", exist_ok=True)


configfile: "config/config.yaml"


name = config["name"]
gaez_cfg = config["data"]["gaez"]


include: "rules/retrieve.smk"
include: "rules/plotting.smk"
include: "rules/yield_gaps.smk"


wildcard_constraints:
    climate_model=r"[a-zA-Z0-9\-]+",
    variable=r"[a-z]+",
    time_period=r"2020s|2050s|2080s",
    rcp=r"[0-9]p[0-9]",
    input_management=r"H|L",
    water_supply=r"r|i|g|s|d",
    co2_fertilization=r"0*",
    crop=r"[a-z\-\w]+",


rule all:
    input:
        f"results/{name}/solved/model.nc",
        # results plots
        f"results/{name}/plots/crop_production.pdf",
        f"results/{name}/plots/resource_usage.pdf",
        f"results/{name}/plots/crop_production.csv",
        f"results/{name}/plots/food_production.csv",
        # maps
        f"results/{name}/plots/regions_map.pdf",
        f"results/{name}/plots/resource_classes_map.pdf",
        f"results/{name}/plots/crop_production_map.pdf",
        f"results/{name}/plots/cropland_fraction_map.pdf",


rule prepare_population:
    input:
        population_gz="data/downloads/WPP_population.csv.gz",
    params:
        planning_horizon=config["planning_horizon"],
    output:
        f"processing/{name}/population.csv",
    script:
        "scripts/prepare_population.py"


rule simplify_gadm:
    input:
        "data/downloads/gadm.gpkg",
    params:
        simplify_min_area_km=config["aggregation"]["simplify_min_area_km"],
        simplify_tolerance_km=config["aggregation"]["simplify_tolerance_km"],
    output:
        "processing/shared/gadm-simplified.gpkg",
    script:
        "scripts/simplify_gadm.py"


rule build_regions:
    input:
        world="processing/shared/gadm-simplified.gpkg",
    params:
        n_regions=config["aggregation"]["regions"]["target_count"],
        allow_cross_border=config["aggregation"]["regions"]["allow_cross_border"],
        cluster_method=config["aggregation"]["regions"]["method"],
        countries=config["countries"],
    output:
        "processing/{name}/regions.geojson",
    script:
        "scripts/build_regions.py"


# Different types of irrigation are available for different crops in
# GAEZ; some crops don't have irrigated yield data at all. This rule
# queries possible GAEZ urls to determine what is available, and
# compiles an overview by crop. It needs to be a checkpoint since the
# outcome will affect which yield data processing rules are run later
# on in the workflow.
checkpoint detect_irrigated_availability:
    params:
        gaez=config["data"]["gaez"],
        crops=config["crops"],
    output:
        f"processing/{name}/irrigated_available_crops.csv",
    script:
        "scripts/detect_irrigated_availability.py"


def gaez_path(kind: str, water_supply: str, code: str) -> str:
    """Return compact GAEZ raster path for a given kind and water supply.

    kind: one of {"yield", "suitability", "actual_yield"}
    water_supply: "r" (rainfed) or irrigation type ("i", "g", "s", "d")
    code: GAEZ crop code (e.g., "whe")
    """
    if kind == "yield":
        prefix = "gaez_potential_yield"
        return (
            f"data/downloads/{prefix}_{gaez_cfg['climate_model']}_{gaez_cfg['time_period']}"
            f"_{gaez_cfg['rcp']}_{gaez_cfg['input_management']}_{water_supply}"
            f"_{gaez_cfg['co2_fertilization']}_{code}.tif"
        )
    if kind == "suitability":
        prefix = "gaez_suitability"
        return (
            f"data/downloads/{prefix}_{gaez_cfg['climate_model']}_{gaez_cfg['time_period']}"
            f"_{gaez_cfg['rcp']}_{gaez_cfg['input_management']}_{water_supply}"
            f"_{gaez_cfg['co2_fertilization']}_{code}.tif"
        )
    if kind == "actual_yield":
        prefix = "gaez_actual_yield"
        return f"data/downloads/{prefix}_{gaez_cfg['actual_yield_year']}_{water_supply}_{code}.tif"
    raise ValueError(f"Unknown kind for _gaez_path: {kind}")


def irrigated_first_type_by_code() -> dict[str, str]:
    """Map crop code -> first available irrig. type from detection CSV."""
    path = checkpoints.detect_irrigated_availability.get(name=name).output[0]
    df = pd.read_csv(path)
    df = df[df["first_available"] != "none"].copy()
    return dict(zip(df["code"].astype(str), df["first_available"]))


def class_inputs_for_yield_max(wildcards):
    # Rainfed for all crops
    files = [
        gaez_path("yield", "r", gaez_cfg["crops"][crop]) for crop in config["crops"]
    ]
    # Irrigated where available: pick the first available type from CSV
    irr_first = irrigated_first_type_by_code()
    for code, t in irr_first.items():
        files.append(gaez_path("yield", t, code))
    return files


rule compute_resource_classes:
    input:
        yields=class_inputs_for_yield_max,
        regions=f"processing/{name}/regions.geojson",
    params:
        resource_class_quantiles=config["aggregation"]["resource_class_quantiles"],
    output:
        classes=f"processing/{name}/resource_classes.nc",
    script:
        "scripts/compute_resource_classes.py"


def suitability_rainfed_inputs(wildcards):
    return [
        gaez_path("suitability", "r", gaez_cfg["crops"][crop])
        for crop in config["crops"]
    ]


def suitability_irrigated_inputs(wildcards):
    files = []
    irr_first = irrigated_first_type_by_code()
    for code, t in irr_first.items():
        files.append(gaez_path("suitability", t, code))
    return files


rule aggregate_class_areas:
    input:
        classes=f"processing/{name}/resource_classes.nc",
        sr=suitability_rainfed_inputs,
        si=suitability_irrigated_inputs,
        irrigated_share="data/downloads/gaez_irrigated_cropland_share.tif",
        regions=f"processing/{name}/regions.geojson",
    params:
        land_limit_dataset=config["aggregation"].get(
            "land_limit_dataset", "suitability"
        ),
    output:
        f"processing/{name}/land_area_by_class.csv",
    script:
        "scripts/aggregate_class_areas.py"


def yield_and_suitability_for_crop(w):
    # Here, the {crop} wildcard is the crop code (e.g., 'whe')
    code = w.crop
    if w.water_supply == "i":
        irr = irrigated_first_type_by_code()
        if code not in irr:
            raise ValueError(f"No irrigated types available for crop code {code}")
        t = irr[code]
    else:
        t = "r"
    y = gaez_path("yield", t, code)
    s = gaez_path("suitability", t, code)
    return {"yield_raster": y, "suitability_raster": s}


rule build_crop_yields:
    input:
        unpack(yield_and_suitability_for_crop),
        classes=f"processing/{name}/resource_classes.nc",
        regions=f"processing/{name}/regions.geojson",
        yield_unit_conversions="data/yield_unit_conversions.csv",
    output:
        f"processing/{name}/crop_yields/{{crop}}_{{water_supply}}.csv",
    script:
        "scripts/build_crop_yields.py"


def yield_inputs(wildcards):
    # Irrigated crops
    irr_cfg = config["irrigation"]["irrigated_crops"]
    if irr_cfg == "auto":
        irrigated_crops = [
            crop
            for crop in config["crops"]
            if gaez_cfg["crops"][crop] in irrigated_first_type_by_code()
        ]
    else:
        irrigated_crops = list(irr_cfg)

    return {
        f"{crop}_yield_{water_supply}": (
            f"processing/{name}/crop_yields/{gaez_cfg['crops'][crop]}_{water_supply}.csv"
        )
        for crop, water_supply in (
            list(zip(config["crops"], itertools.repeat("r")))  # Rainfed
            + list(zip(irrigated_crops, itertools.repeat("i")))
        )
    }


rule build_model:
    input:
        unpack(yield_inputs),
        crops="data/crops.csv",
        foods="data/foods.csv",
        feed_conversion="data/feed_conversion.csv",
        feed_to_products="data/feed_to_animal_products.csv",
        food_groups="data/food_groups.csv",
        nutrition="data/nutrition.csv",
        regions="processing/{name}/regions.geojson",
        land_area_by_class="processing/{name}/land_area_by_class.csv",
        population="processing/{name}/population.csv",
        prices=f"processing/{name}/faostat_prices.csv",
    params:
        crops=config["crops"],
        countries=config["countries"],
        primary=config["primary"],
        food_groups=config["food_groups"],
        macronutrients=config["macronutrients"],
        animal_products=config["animal_products"],
        trade=config["trade"],
    output:
        network="results/{name}/build/model.nc",
    script:
        "scripts/build_model.py"


rule solve_model:
    input:
        network="results/{name}/build/model.nc",
    params:
        primary=config["primary"],
        ghg_price=config["emissions"]["ghg_price"],
        solver=config["solving"]["solver"],
        solver_options=config["solving"].get(
            f"options_{config['solving']['solver']}", {}
        ),
    output:
        network="results/{name}/solved/model.nc",
    script:
        "scripts/solve_model.py"
