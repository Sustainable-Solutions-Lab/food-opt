# SPDX-FileCopyrightText: 2025 Koen van Greevenbroek
#
# SPDX-License-Identifier: GPL-3.0-or-later

from snakemake.utils import min_version
import os
import itertools
import csv

min_version("9.0")

os.makedirs("data/downloads", exist_ok=True)


configfile: "config/config.yaml"


name = config["name"]
gaez_cfg = config["data"]["gaez"]
grazing_cfg = config.get("grazing", {})


with open("data/gaez_crop_code_mapping.csv", newline="") as _gaez_mapping_file:
    _GAEZ_CODE_MAPPING = {
        row["crop_name"]: {
            "res02": row["res02_code"],
            "res05": row["res05_code"],
            "res06": row["res06_code"],
        }
        for row in csv.DictReader(_gaez_mapping_file)
    }


def get_gaez_code(crop_name: str, module: str) -> str:
    """Look up the GAEZ RES code for a given crop and module."""

    module_key = module.lower()
    if module_key not in {"res02", "res05", "res06"}:
        raise ValueError(f"Unknown GAEZ module '{module}'")

    try:
        code = _GAEZ_CODE_MAPPING[crop_name][module_key]
    except KeyError as exc:
        raise ValueError(f"Crop '{crop_name}' not found in mapping") from exc

    if not code:
        raise ValueError(f"Crop '{crop_name}' has no {module_key} code")

    return code.strip().upper()


include: "rules/retrieve.smk"
include: "rules/plotting.smk"
include: "rules/yield_gaps.smk"


wildcard_constraints:
    climate_model=r"[a-zA-Z0-9\-]+",
    period=r"[A-Z0-9]+",
    scenario=r"[A-Z0-9]+",
    input_level=r"H|L",
    water_supply=r"[ri]",
    crop=r"[a-zA-Z0-9\-]+",
    item=r"[a-zA-Z0-9_-]+",


rule all:
    input:
        f"results/{name}/solved/model.nc",
        # results plots
        f"results/{name}/plots/crop_production.pdf",
        f"results/{name}/plots/resource_usage.pdf",
        f"results/{name}/plots/crop_production.csv",
        f"results/{name}/plots/food_production.csv",
        f"results/{name}/plots/objective_breakdown.pdf",
        f"results/{name}/plots/objective_breakdown.csv",
        f"results/{name}/plots/health_risk_map.pdf",
        f"results/{name}/plots/health_risk_by_region.csv",
        f"results/{name}/plots/health_baseline_map.pdf",
        f"results/{name}/plots/health_baseline_by_region.csv",
        # maps
        f"results/{name}/plots/regions_map.pdf",
        f"results/{name}/plots/resource_classes_map.pdf",
        f"results/{name}/plots/crop_production_map.pdf",
        f"results/{name}/plots/crop_land_use_map.pdf",
        f"results/{name}/plots/cropland_fraction_map.pdf",
        f"results/{name}/plots/irrigated_cropland_fraction_map.pdf",
        f"results/{name}/plots/crop_use_breakdown.pdf",
        f"results/{name}/plots/crop_use_breakdown.csv",
        f"results/{name}/plots/water_value_map.pdf",
        f"results/{name}/plots/food_consumption.pdf",


rule prepare_population:
    input:
        population_gz="data/downloads/WPP_population.csv.gz",
    params:
        planning_horizon=config["planning_horizon"],
        countries=config["countries"],
        health_reference_year=config["health"]["reference_year"],
    output:
        population=f"processing/{name}/population.csv",
        population_age=f"processing/{name}/population_age.csv",
    script:
        "scripts/prepare_population.py"


rule simplify_gadm:
    input:
        "data/downloads/gadm.gpkg",
    params:
        simplify_min_area_km=config["aggregation"]["simplify_min_area_km"],
        simplify_tolerance_km=config["aggregation"]["simplify_tolerance_km"],
    output:
        "processing/shared/gadm-simplified.gpkg",
    script:
        "scripts/simplify_gadm.py"


rule build_regions:
    input:
        world="processing/shared/gadm-simplified.gpkg",
    params:
        n_regions=config["aggregation"]["regions"]["target_count"],
        allow_cross_border=config["aggregation"]["regions"]["allow_cross_border"],
        cluster_method=config["aggregation"]["regions"]["method"],
        countries=config["countries"],
    output:
        "processing/{name}/regions.geojson",
    script:
        "scripts/build_regions.py"


rule prepare_gdd_dietary_intake:
    input:
        gdd_dir="data/manually_downloaded/GDD-dietary-intake",
    params:
        reference_year=config["health"]["reference_year"],
    output:
        diet="processing/{name}/gdd_dietary_intake.csv",
    script:
        "scripts/prepare_gdd_dietary_intake.py"


rule prepare_health_costs:
    input:
        regions="processing/{name}/regions.geojson",
        diet="processing/{name}/gdd_dietary_intake.csv",
        rr_int="data/health/raw/RR_int_05282021.csv",
        rr_max="data/health/raw/RR_max_05282021.csv",
        dr="data/health/raw/dr_05282021.csv",
        population="processing/{name}/population_age.csv",
        life_table="data/downloads/WPP_life_table.csv.gz",
    params:
        countries=config["countries"],
        health=config["health"],
    output:
        risk_breakpoints="processing/{name}/health/risk_breakpoints.csv",
        cluster_cause="processing/{name}/health/cluster_cause_baseline.csv",
        cause_log="processing/{name}/health/cause_log_breakpoints.csv",
        cluster_summary="processing/{name}/health/cluster_summary.csv",
        clusters="processing/{name}/health/country_clusters.csv",
    script:
        "scripts/prepare_health_costs.py"


def gaez_path(kind: str, water_supply: str, crop: str) -> str:
    """Return GAEZ v5 raster path for a given kind and water supply.

    kind: one of {"yield", "suitability", "water_requirement", "growing_season_start", "growing_season_length", "actual_yield"}
    water_supply: "i" (irrigated) or "r" (rainfed)
    crop: crop name (e.g., "wheat")
    """
    ws = water_supply.lower()
    if ws not in {"i", "r"}:
        raise ValueError(f"Unsupported water supply '{water_supply}'")

    if kind == "actual_yield":
        return f"data/downloads/gaez_actual_yield_{ws}_{crop}.tif"

    climate = gaez_cfg["climate_model"]
    period = gaez_cfg["period"]
    scenario = gaez_cfg["scenario"]
    input_level = gaez_cfg["input_level"]

    prefix_by_kind = {
        "yield": "data/downloads/gaez_yield",
        "water_requirement": "data/downloads/gaez_water",
        "suitability": "data/downloads/gaez_suitability",
        "growing_season_start": "data/downloads/gaez_growing_season_start",
        "growing_season_length": "data/downloads/gaez_growing_season_length",
    }

    try:
        prefix = prefix_by_kind[kind]
    except KeyError as exc:
        raise ValueError(f"Unknown kind for gaez_path: {kind}") from exc

    return f"{prefix}_{climate}_{period}_{scenario}_{input_level}_{ws}_{crop}.tif"


rule compute_resource_classes:
    input:
        yields=(
            [gaez_path("yield", "r", crop) for crop in config["crops"]]
            + [gaez_path("yield", "i", crop) for crop in config["crops"]]
        ),
        regions=f"processing/{name}/regions.geojson",
    params:
        resource_class_quantiles=config["aggregation"]["resource_class_quantiles"],
    output:
        classes=f"processing/{name}/resource_classes.nc",
    script:
        "scripts/compute_resource_classes.py"


rule aggregate_class_areas:
    input:
        classes=f"processing/{name}/resource_classes.nc",
        sr=[gaez_path("suitability", "r", crop) for crop in config["crops"]],
        si=[gaez_path("suitability", "i", crop) for crop in config["crops"]],
        irrigated_share="data/downloads/gaez_land_equipped_for_irrigation_share.tif",
        regions=f"processing/{name}/regions.geojson",
    params:
        land_limit_dataset=config["aggregation"].get(
            "land_limit_dataset", "suitability"
        ),
    output:
        f"processing/{name}/land_area_by_class.csv",
    script:
        "scripts/aggregate_class_areas.py"


def yield_and_suitability_for_crop(w):
    """Get input files for build_crop_yields rule.

    w.crop is the crop name (e.g., 'wheat')
    w.water_supply is 'i' or 'r'
    """
    crop = w.crop
    ws = w.water_supply

    inputs = {
        "yield_raster": gaez_path("yield", ws, crop),
        "suitability_raster": gaez_path("suitability", ws, crop),
        "growing_season_start_raster": gaez_path("growing_season_start", ws, crop),
        "growing_season_length_raster": gaez_path("growing_season_length", ws, crop),
    }
    if ws == "i":
        inputs["water_requirement_raster"] = gaez_path("water_requirement", ws, crop)
    return inputs


rule build_crop_yields:
    input:
        unpack(yield_and_suitability_for_crop),
        classes=f"processing/{name}/resource_classes.nc",
        regions=f"processing/{name}/regions.geojson",
        yield_unit_conversions="data/yield_unit_conversions.csv",
    output:
        f"processing/{name}/crop_yields/{{crop}}_{{water_supply}}.csv",
    script:
        "scripts/build_crop_yields.py"


rule build_grassland_yields:
    input:
        grassland="data/downloads/grassland_yield_historical.nc4",
        classes=f"processing/{name}/resource_classes.nc",
        regions=f"processing/{name}/regions.geojson",
    output:
        f"processing/{name}/grassland_yields.csv",
    script:
        "scripts/build_grassland_yields.py"


rule extract_waterfootprint_appendix:
    input:
        zip_path="data/downloads/Report53_Appendix.zip",
    output:
        shapefile="data/downloads/Report53_Appendix/Report53-BlueWaterScarcity-ArcGIS-ShapeFile/Monthly_WS_GRDC_405_basins.shp",
        excel="data/downloads/Report53_Appendix/Report53-Appendices-VI-IX.xls",
    shell:
        r"""
        unzip -o {input.zip_path} -d data/downloads
        """


rule process_blue_water_availability:
    input:
        shapefile=rules.extract_waterfootprint_appendix.output.shapefile,
        excel=rules.extract_waterfootprint_appendix.output.excel,
    output:
        f"processing/{name}/water/blue_water_availability.csv",
    script:
        "scripts/process_blue_water_availability.py"


def crop_yield_file_list(w):
    return list(yield_inputs(w).values())


rule build_region_water_availability:
    input:
        shapefile=rules.extract_waterfootprint_appendix.output.shapefile,
        regions=f"processing/{name}/regions.geojson",
        monthly=f"processing/{name}/water/blue_water_availability.csv",
        crop_yields=crop_yield_file_list,
    output:
        monthly_region=f"processing/{name}/water/monthly_region_water.csv",
        region_growing=f"processing/{name}/water/region_growing_season_water.csv",
    script:
        "scripts/build_region_water_availability.py"


def yield_inputs(wildcards):
    """Get all crop yield files for model building."""
    irr_cfg = config["irrigation"]["irrigated_crops"]
    if irr_cfg == "all":
        irrigated_crops = config["crops"]
    else:
        irrigated_crops = list(irr_cfg)

    return {
        f"{crop}_yield_{water_supply}": f"processing/{name}/crop_yields/{crop}_{water_supply}.csv"
        for crop, water_supply in (
            list(zip(config["crops"], itertools.repeat("r")))  # Rainfed
            + list(zip(irrigated_crops, itertools.repeat("i")))
        )
    }


rule build_model:
    input:
        unpack(yield_inputs),
        crops="data/crops.csv",
        foods="data/foods.csv",
        feed_conversion="data/feed_conversion.csv",
        feed_to_products="data/feed_to_animal_products.csv",
        food_groups="data/food_groups.csv",
        nutrition="data/nutrition.csv",
        regions="processing/{name}/regions.geojson",
        land_area_by_class="processing/{name}/land_area_by_class.csv",
        population="processing/{name}/population.csv",
        prices=f"processing/{name}/faostat_prices.csv",
        grassland_yields=f"processing/{name}/grassland_yields.csv",
        monthly_region_water=f"processing/{name}/water/monthly_region_water.csv",
        growing_season_water=f"processing/{name}/water/region_growing_season_water.csv",
        blue_water_availability=f"processing/{name}/water/blue_water_availability.csv",
    params:
        crops=config["crops"],
        countries=config["countries"],
        primary=config["primary"],
        food_groups=config["food_groups"],
        macronutrients=config["macronutrients"],
        animal_products=config["animal_products"],
        trade=config["trade"],
        grazing=grazing_cfg,
    output:
        network="results/{name}/build/model.nc",
    script:
        "scripts/build_model.py"


rule solve_model:
    input:
        network="results/{name}/build/model.nc",
        health_risk_breakpoints="processing/{name}/health/risk_breakpoints.csv",
        health_cluster_cause="processing/{name}/health/cluster_cause_baseline.csv",
        health_cause_log="processing/{name}/health/cause_log_breakpoints.csv",
        health_cluster_summary="processing/{name}/health/cluster_summary.csv",
        health_clusters="processing/{name}/health/country_clusters.csv",
        food_risk_map="data/health/food_to_risk_factor.csv",
        population="processing/{name}/population.csv",
    params:
        primary=config["primary"],
        ghg_price=config["emissions"]["ghg_price"],
        solver=config["solving"]["solver"],
        solver_options=config["solving"].get(
            f"options_{config['solving']['solver']}", {}
        ),
    output:
        network="results/{name}/solved/model.nc",
    script:
        "scripts/solve_model.py"
